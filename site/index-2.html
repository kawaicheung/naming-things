<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="https://fonts.googleapis.com/css?family=Fredericka+the+Great|Lora:400,400i,700,700i|Raleway:400,600,800|Roboto+Mono&display=swap" rel="stylesheet">
	<link href="styles-2.css" rel="stylesheet" type="text/css" />
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
</head>
<body>
<div class="menu">
  <a href="">
    <svg height="32px" id="Layer_1" style="enable-background:new 0 0 32 32;" version="1.1" viewBox="0 0 32 32" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
      <path d="M4,10h24c1.104,0,2-0.896,2-2s-0.896-2-2-2H4C2.896,6,2,6.896,2,8S2.896,10,4,10z M28,14H4c-1.104,0-2,0.896-2,2  s0.896,2,2,2h24c1.104,0,2-0.896,2-2S29.104,14,28,14z M28,22H4c-1.104,0-2,0.896-2,2s0.896,2,2,2h24c1.104,0,2-0.896,2-2  S29.104,22,28,22z"/>
    </svg>
  </a>
</div>
<div class="toc">
  <ul>
    <li><a href="#ch-introduction">Introduction</a></li>
    <li><a href="#ch-imagining-objects">Imagining Objects</a></li>
    <li><a href="#ch-hunting-for-names">Hunting for Names</a></li>
    <li><a href="#ch-surfacing-parameters">Surfacing Parameters</a></li>
    <li><a href="#ch-shape-of-code">The Shape of Code</a></li>
    <li><a href="#ch-when-opposites-dont-attract">When Opposites Don't Attract</a></li>
    <li><a href="#ch-tautologous-name-trap">The Tautologous Name Trap</a></li>
    <li><a href="#ch-names-are-fickle">Names are Fickle</a></li>
    <li><a href="#ch-abstracting-to-soon">Abstracting too Soon</a></li>
    <li><a href="#ch-speaking-the-native-tongue">Speaking the Native Tongue</a></li>
    <li><a href="#ch-naming-to-teach">Naming to Teach</a></li>
    <li><a href="#">Naming Completely?</a></li>
    <li><a href="#">Making Names Memorable?</a></li>
    <li class="extended"><a href="#ch-about-this-book">About this book</a></li>
  </ul>
</div>

<div class="bookmark">
</div>
<div class="grid-cover">
  <div class="cover">
    <h1>Naming Things.</h1>
    <h2>A short book dedicated to one of coding's most elusive tasks.</h2>
    <h3>By Ka Wai Cheung, creator and co-founder of <a href="https://www.donedone.com" target="_blank">DoneDone</a>.</h3>
    <h4><a href="#" id="btn-cover-click">Start reading...</a></h4>
    <h5>Copyright &copy; 2019-2020, DoneDone LLC. All rights reserved.
  </div>  
</div>

<div class="chapter" id="ch-introduction">
  <div class="grid-content">
    <div class="content">
      <h2>Introduction</h2>
      <p class="emphasis">
        Here's a little insight into what I think about when I write code.
      </p>
      <p>
        So, I'm working on&mdash;what I'll call for now&mdash;a <em>data migration</em> feature. It's for the brand new version of <a href="https://www.donedone.com">DoneDone</a>, the issue tracking and customer support app I created and have continued to work on for over a decade. Developing a product for this long, I'm intimately familiar with the code&mdash;like a scupltor chiseling away endlessly at a large piece of stone.
      </p>
      <p>
        The goal of this migration feature is to give our customers an easy way to bring their existing data over from the old version of DoneDone (which we call <em>Classic</em>) over to this new version. I wish I could tell you this is a simple mapping of database tables and columns from Classic over to the new version, but it's not. The new DoneDone is markedly different from its predecessor: Some data maps simply, other data requires some massaging, and some stuff simply can't be mapped at all.
      </p>
      <p>
        For the next week, I chisel away at this feature&mdash;top to bottom. I develop a screen to sign in to the old system, one to let users choose the projects they want to move over, and one to see the progress of their migration request. On the backend, I work on a number of database updates to store these requests. I then write a separate service that picks up these requests to perform the arduous work of moving this data over &ldquo;cleanly&rdquo;. There are other tangential pieces I build along the way, like emailing the requester when the migration is complete and broadcasting error notifications.
      </p>
      <p>
        It's intense work but after a week, I feel confident about the new feature.
      </p>
      <p>
        Before I'm ready to release it, I give my code another onceover&mdash;like re-reading a manuscript from the beginning again with a fresh set of eyes. I tend to pick out things I don't like about my code best this way.
      </p>
      <p>
        The first thing I look at is naming. I try to use the same terms when I write code as when I <em>talk</em> about the feature. This avoids any unnecessary mental mapping when I transition between the screen and the rest of the world. So naturally, my codebase is littered with derivates of the word <em>migration</em>.
      </p>
      <ul>
        <li>There's a <code>ClassicMigrator</code> project in my codebase.</li>
        <li>Methods named <code>QueueMigrationRequest()</code> and <code>MigrateClassicProjects()</code>.</li>
        <li>Class properties like <code>EligibleForMigration</code> and <code>HasMigratableProjects</code>.</li>
        <li>There are models, views, and controllers with every derivative of <em>Migrate</em> sprinkled around. The copy on the application uses the words <em>migrate</em> and <em>migration</em> too.
      </li>
      </ul>
      <p>
        On this re-read, the word is eating at me. Mike (my business partner) and I have been using the word "migration" in reference to this feature the whole time. It's an important word to get right. 
      </p>
      <p>
        Sometimes you use a word so much that you no longer think about what it actually means; You just know what it's <em>supposed</em> to mean. Here's the problem: We aren't actually migrating data. 
      </p>
      <p>
        Migrate has this connotation that something is leaving one place to go to another, like a flock of birds migrating south for the winter. In our case, data isn't leaving the Classic version. That data is still there&mdash;untouched&mdash;after the migration. I wrote it this way so existing customers can try the new system using their existing data, but if they don't like it, they can stick with Classic.
      </p>
      <p>
        Migrate is misleading. Using that word in the application copy might make customers apprehensive about their existing data. Using that word in code might confuse future developers about what the feature actually does.
      </p>
      <p>
        I contemplate replacing <em>migration</em> with <em>copy</em>. It's clear that copying doesn't mean removing the original. But, this isn't quite right either. As I mentioned earlier, this data transfer isn't a literal copy. There are some things that don't translate perfectly, or at all. Copying also seems like a fast, mindless operation&mdash;a simple <span class="key">CTRL</span>+<span class="key">C</span> <span class="key">CTRL</span>+<span class="key">V</span> exercise. That's not what this is.
      </p>
      <p>
        I tell Mike about my conundrum. 
      </p>
      <p>
        After some thought, he suggests we use the word <em>import</em> instead. Ah ha!
      </p>
      <p>
        There's a heftiness to the word <em>import</em> that feels right. Whenever I think about importing data, I envision metallic gear icons  and the momentary spiking of CPU graphs. Even when you import things in the real world, it has that same feeling of heft&mdash;huge cargo ships meandering across the ocean lugging thousands of tons of goods.
      </p>
      <p>
        The word <em>import</em>, as it's normally used in technical terms, also doesn't feel like data is leaving one place and going to another. I think of importing data from a file I've uploaded. I know the data on the file doesn't disappear. I also don't necessarily expect this one-to-one mapping between my data and the imported data. Import seems like the perfect word to me.
      </p>
      <p>
        So, I end up substituting <em>migrate</em>, and all its various derivatives, with <em>import</em>. I'm much happier with this change.
      </p>
      <hr />
      <p>
        I obsess over names. Finding that perfect name gives me the same kind of adrenaline boost I get after I've solved a difficult problem or figured out a much cleaner approach to an ugly solution. 
      </p>
      <p>
        My obsession with naming started from a quote I read some time ago. If you've written code long enough, there's a good chance you've heard it as well.
      </p>
      <blockquote>
        &ldquo;There are only two hard things in Computer Science: cache invalidation and naming things.&rdquo;
      </blockquote>
      <div class="quoter">
        Phil Karlton
      </div>
      <p>
        Karlton was a software architect at Netscape. There is suprisingly little other information I could find about him though I'm sure he did great work. But, it's this quote that he will be forever remembered by in the programming industry.
      </p>
      <p>
        The first time I read this quote, I remember chuckling to myself. First, because I can think of many things that are difficult for me in programming. Second, because naming wasn't initially among those things; I had never thought about naming as a difficult exercise. Yet, we all have written and read names that confuse, misdirect, conflate, or otherwise mistify us. 
      </p>
      <p>
        So, how do you name things well? Unlike so many other things in programming, an incoherent name won't be caught by the compiler. There are no metrics for naming. A bad name won't break your code. A good name won't speed up your build.
      </p>
      <p>
        Naming is elusive. It has a lot to do with gut, feel, style and even aesthetics. It is, in my humble opinion, the most human of technical subjects. Naming is subjective.
      </p>
      <p>
        Though there are no metrics for good names, it deserves as much attention as all the other skills we preach in programming&mdash;like good architecture, writing "clean code", or rigid testing. While these other practices are critical, they share the common drawback that you cannot see these things instantly. It's only after digesting the codebase and working with it for awhile that you reap its benefits. 
      </p>
      <p>
        On the other hand, there's an immediate payoff to a codebase with good names. They are the first things a programmer sees when reading  new code. They make code more approachable. With modern tooling, you can also change the names of things safely and quickly.
      </p>
      <hr />
      <p>
        This book is about how focusing on names can drive us toward better code&mdash;regardless of the languages, tools, or development environment you use. Many of the examples in this book come directly from, or were inspired by, real code I've written for DoneDone over the past decade. <a href="#ch-imagining-objects">Let's begin</a>.
      </p>
    </div>
  </div>
</div>
<div class="chapter" id="ch-imagining-objects">
  <div class="grid-content">
    <div class="content">
      <h2>Imagining Objects</h2>
      <p class="emphasis">
        I think the term <em>object-oriented programming</em> is misleading.
      </p>
      <p>
        Textbooks tend to demonstrate classes and interfaces by using dogs, cats, and other domesticated animals. But, these aren't realistic examples for most coders. Most of the things we call "objects" in code don't have a direct physical representation in the real world. 
      </p>
      <p>
        We should really call it noun-oriented programming. A noun can be a person, place, thing, or idea. Most classes really are <em>ideas with functionality</em>. 
      </p>
      <p>
        Classes sometimes manifest because we find ourselves with a set of functions and properties that have a common purpose that we want to wrap up in a neat little bundle. But, these classes don't always have a physical translation. This is where wishy-washy names like <code>UserManager</code>, <code>MessagingHelper</code>, and <code>AppHandler</code> are born. 
      </p>
      <p>
        Working through a codebase littered with these kinds of class names reminds me of working in a bloated organization where everybody is some form of middle-management. When, exactly, should I direct a question to the <em>Regional Vice Account Manager</em> as opposed to the <em>District Assistant Account Principal</em>?
      </p>
      <p>
        When I read code like this, I have to dig into these classes to figure out what purpose they serve. When I know there's some functionality out there I want to leverage, I have a harder time remembering where it lives. <em>Was it in that helper doohickey or in the other manager thingamajig?</em> 🤔
      </p>
      <p>
        There are ways around this. Generic names might be a sign that the guts of the class belong elsewhere. For instance, maybe the methods inside that <code>UserManager</code> class can be moved into the <code>User</code> class itself. It might also be a sign that the class does too many things and needs to be split up into smaller pieces. Perhaps there are natural groupings inside that <code>AppHandler</code> class&mdash;one that handles initialization, one that handles routing, one that deals with exception handling, and so forth. More specific names can be derived from there.
      </p>
      <p>
        If it's neither of those cases, sometimes I just have to face reality: A class can be hard to name because it does something that doesn't easily translate in the real world. That's when a little imagination helps. Even when a class is responsible for something that only makes sense in my code, there's usually some metaphorical noun out there I can apply to it to make it memorable. This makes it easier to recall when I need to revisit that &ldquo;object&rdquo; again.
      </p>
      <hr />
      <p>
        The other day, I was looking at code I wrote awhile back that allows DoneDone users to reset their password. The reset password function works like most other apps:
      </p>
      <ul>
        <li>A user enters their email address in a &ldquo;Forgot Password&rdquo; form from the app.</li>
        <li>They receive an email with a link containing an encrypted token embedded in the querystring.</li>
        <li>When clicked, the request passes the token to the server and is decrypted.</li>
        <li>The information from the decryption determines whether the reset link is still valid and which user originally requested the reset.</li>
      </ul>
      <p>
        On this re-read, I don't like how the token concept is implemented. Bits of logic are sprinkled in too many places. The token is encrypted on one layer of the stack and decrypted on a completely different layer. There are also a couple of places where I write repeated code to check whether the token is still valid. 
      </p> 
      <p>
        But, what makes me most hungry to clean this code up is that the concept is <em>nearly identical</em> to the process for a user takes to complete their initial registration.
      </p>
      <p>
        It's clear that a better approach is to wrap up this token into a single object. Let the object handle all of it&mdash;the encryption, decryption, and validation of the token. Then, I can re-use it for both the password reset and user registration processes.
      </p>
      <p>
        I get to a place I'm quite happy with. The guts of the object look something like this. 
      </p>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        Taking a quick walkthrough of this object, you'll notice that there are two constructors. 
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="1-d1">One hydrates the properties of the object with a <code>user_id</code> and <code>email</code> of the user when a password reset (or registration completion request) is initiated</a>. The timestamp of the token is set to the moment the object instance is created. It also wraps all of this data together into an encrypted token. 
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="1-d2">The other hydrates the same object with the encrypted token. The token is decrypted and the other properties are deduced from the decryption</a>. This is called during the request when a user clicks the link they received from the email.
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="1-d3">The <code>IssueWithinMinutes</code> public method allows code elsewhere to decide whether to honor the request</a>. For instance, a password reset link might be valid for only ten minutes whereas a user registration link could be valid for a few hours.
      </p>
    </div>
    <div class="code-block">
      <pre>
public sealed class <span class="blanked">AuthToken</span>
{
  private readonly DateTime _utc_date_issued;

  public readonly int UserID;
  public readonly string EmailAddress;
  public readonly string EncryptedToken;

  <span class="1-d1">public AuthToken(int user_id, string email)
  {
    UserID = user_id;
    EmailAddress = email.ToLower().Trim();
    _utc_date_issued = DateTime.UtcNow;
    EncryptedToken = // Omitted for simplicity...
  }</span>

  <span class="1-d2">public AuthToken(string encrypted_token)
  {
    try
    {
       EncryptedToken = encrypted_token;
       UserID = // Deduced from the token...
       EmailAddress = // Deduced from the token...
       _utc_date_issued = // Deduced from the token...
    }
    catch
    {
      throw new InvalidInput("Cannot decrypt token!");
    }
  }</span>

  <span class="1-d3">public bool IssuedWithinMinutes(int minutes)
  {
    return (_utc_date_issued.AddMinutes(minutes) > DateTime.UtcNow);
  }</span>
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        I'm giddy with the promises of such an object. I'm able to clean up some duplicate logic used by both the password reset and user registration processes. Whereas the encryption and decryption process once lived in random helper methods on different layers of the stack, they now have a comfortable home.
      </p>
      <p>
        The last hurdle, however, is a big one&mdash;what do I name this thing? This "object" is not a dog or cat. I don't really know what this thing is. 
      </p>
      <p>
        My first attempt, <code>AuthToken</code> was a half-hearted one. I just wanted to get something down so I can finish the implementation. Reading this name again brings up all sorts of questions and lackluster answers.
      </p>
      <ul>
        <li>
          <strong>Does "Auth" mean "Authorization" or "Authentication"?</strong> In this case, it kind of means <em>both</em>. That doesn't really help.
        </li>
        <li>
          <strong>Does this object represent the encrypted token?</strong> Kind of. It really represents the encrypted token <em>in addition to</em> the data the token represents. Calling it <code>AuthToken</code> while also having a property with the name <code>EncryptedToken</code> is confusing. It's more than just the token. It's easy to get into the trap of naming an object on only part of its reason for being.
        </li>
        <li>
          <strong>What is it supposed to be used for?</strong> In the lexicon of object naming, <code>AuthToken</code> is about as generic as <code>UserManager</code>.
        </li>
      </ul>
      <p>
        This isn't the right name. What comparable thing possibly exists in the real world like this? 
      </p>
      <p>
        I begin to think about something that an <em>authority</em> creates for someone, and that person can later exchange for access to do whatever the authority agreed they can do. There's a quality of <em>redeeming</em> this thing. 
      </p>
      <p>
        A <em>ticket</em> comes to mind. But, that conjures up thoughts of going to a sporting event or movie premiere, as if there's a specific time and place to redeem it. It also makes me think of a parking ticket. Password resets and user registrations are neither particularly exciting nor dreadful. Neither metaphor feels close to right. 
      </p>
      <p>
        A <em>permit</em>? A permit is valid for a set period of time and it lets someone do something agreed to by an authority until it expires. Plus, a permit is something given to you usually by a governing body, not your local movie theater or sporting venue. That feels like the right move.👌
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="1-d4">I end up changing the class name to <code>PermitForUserUpdate</code></a>. The implementation instantly feels more readable. For instance, <a href="#" class="code-ref" data-code-ref="1-d5">the method <code>IssuedWithinMinutes()</code> reads more naturally</a> when used in context. Permits in the real world are normally <em>issued</em>. Here's how I can validate a password reset permit hasn't expired yet.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
var permit = new <span class="1-d4">PermitForUserUpdate</span>(encrypted_token);

if (!<span class="1-d5">permit.IssuedWithinMinutes(10)</span>)
{
  throw new Exception("This permit is expired!");
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <hr />
      <p>
        When opportunities like these present themselves in your code, stop for a minute and see if you can find a replacement for that really vague class name. Renaming classes might require a little bit of imagination, but done repeatedely, your objects become more memorable and your codebase starts to read more fluidly.
      </p>
    </div>
  </div>
</div>

<div class="chapter" id="ch-hunting-for-names">
  <div class="grid-content">
    <div class="content">
      <h2>Hunting For Names</h2>
      <p class="emphasis">
        There never seems to be time to clean up code. 
      </p>
      <p>
        No client wants to pay for it. No product manager wants to see time spent with no feature improvements. We sometimes have to clean up&mdash;surreptitiously&mdash;as we go.
      </p>
      <blockquote class="smaller">
        &ldquo;Of course, many [managers] say they are driven by quality but are more driven by schedule...In these cases I give my more controversial advice: Don't tell! Subversive? I don't think so.&rdquo;
      </blockquote>
      <div class="quoter">
        Martin Fowler, <a href="https://martinfowler.com/books/refactoring.html">Refactoring: Improving the Desing of Existing Code</a>
      </div>
      <p>
        The good news is, you don't need a long stretch of dedicated time to make positive impacts on your code. You can get a lot done in small spurts. One of my favorite exercises is one of the simplest: <em>Find things to name</em>. I look for bits of logic over-exposed logic, then replace the logic with a method or property I can define with a meaningful name. Done repeatedly, it can quickly make souring code sweet. 
      </p>
      <p>
         So what's overexposed logic? Here's an example.
      </p>
      <hr />
      <p>
        On the new DoneDone, we're using <a href="https://vuejs.org/">Vue.js</a> to deliver parts of our front-end. On inspection, I noticed a conditional on a Vue element that looks like this:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
&lt;div <span class="2-d1">v-if="!['xs', 'sm', 'md'].includes($mq)"</span>&gt;
    ...
&lt;/div&gt;</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        If you're unfamiliar with Vue's syntax, no big deal. The <a href="#" class="code-ref" data-code-ref="2-d1"><code>v-if</code> attribute</a> is Vue syntax that works just like a normal <code>if</code> statement, with a Typescript expression inside of it. On an HTML element, it determines if that element should be rendered. In this case, I have a <code>&lt;div&gt;</code> element that I only want to show if the Typescript statement <code>!['xs', 'sm', 'md'].includes($mq)</code> is true.
      </p>
      <p>
        But, what does this code <em>actually</em> mean? Well, it evaluates to <code>true</code> if the "extra small", "small", or "medium" media query breakpoints are <em>not</em> hit based on the size of the browser. Put more meaningfully, <em>it tells us if the current browser width is sized to at least the width of a normal desktop screen</em>.
      </p>
      <p>
        When I scan this statement, it looks cryptic. Out-of-place. Too specific in the context of the code around it. 
      </p>
      <p>
        I can quickly fix this line by swapping the logic with a well-named property, like <a href="#" class="code-ref" data-code-ref="2-d2"><code>isDesktopWidth</code></a>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
<span class="2-d2">isDesktopWidth()</span>: boolean {
  return !['xs', 'sm', 'md'].includes(this.$mq)
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Now, I get the satisfaction of cleaning up my original code up with something much more approachable.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
&lt;div v-if="isDesktopWidth"&gt;
    ...
&lt;/div&gt;</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Not only does this read better, but I have a property I can reuse again in other parts of my code.
      </p>
      <hr />
      <p>
        You can spot code like this from a mile away&mdash;an overly technical bit of code lying around without a proper home. I usually write code like this on the first pass, when I'm just trying to get a feature to work right and I don't care about where all the pieces fit. If I never make that second pass, however, then things quickly turn ugly.
      </p>
      <p>
        In my earlier days, it would be easy to forget to do that second pass because I got lost in the euphoria of simply getting code to work right&mdash;or I was already past the deadline I've set for myself to do so.
      </p>
      <p>
        But, I don't skip that second pass anymore. It's this pass where I focus heavily on naming. Where I look to say <em>what</em> rather than <em>how</em>. Where the readability of my code improves dramatically. 
      </p>
      <p>
        Take a moment to look at your own code&mdash;especially in the "higher" areas of your stack where the semantics really <em>should</em> be more human-readable. You might be surprised how many bits of messy logic are sprinkled about that you could wrap up into a meaningful name.
      </p>
      <h3>Empowering your objects</h3>
      <p>
        Logic bits don't always have to look overly <em>technical</em> to benefit from replacing it with a named method or property. 
      </p>
      <p>
         Even in the cases where I might see business logic already using the well-named properties of an object, there's usually a way I can name that piece of logic and push it <em>back</em> into the class definition. Here's an example. 
      </p>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        I have a <code>Person</code> class that houses some basic information used throughout my codebase.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public class Person
{
    public string FirstName;
    public string LastName;
    public DateTime LastAccessTimestamp;
    public AccountRole Role;
    ...
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Instances of <code>Person</code> naturally spring up all over the place.
      </p>
    </div>
  </div>
  <div class="grid-left-code">
    <div class="content">
      <p>
        For example, on a person's profile screen, <a href="#" class="code-ref" data-code-ref="2-d3">I have an instance of <code>Person</code> named <code>authedPerson</code></a> used to display an authenticated user's full name and a few links to other sections of the application they have access to, only if they are an admin or owner in the account.
      </p>
    </div>
    <div class="code-block">
      <pre>
&lt;div&gt;
  &lt;h2&gt;<span class="2-d3">@authedPerson.FirstName @authedPerson.LastName</span>&lt;/h2&gt;
  @if (<span class="2-d3">authedPerson.Role == AccountRole.ADMIN || 
       authedPerson.Role == AccountRole.OWNER</span>)
  {
      &lt;a href="..."&gt;Edit&lt;/a&gt; | &lt;a href="..."&gt;Cancel&lt;/a&gt;
  }
&lt;/div&gt;</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        In another part of the application, <a href="#" class="code-ref" data-code-ref="2-d4">I use a person's first name and last initial</a> to prep notification messages when they update an issue.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
// e.g. "Mary D. updated the issue."
var subject = <span class="2-d4">person.FirstName + " " +  person.LastName.Substring(0,1) + "."</span> + " updated the issue.";</pre>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        I also have a method inside of a security class that checks <a href="#" class="code-ref" data-code-ref="2-d5">if a person has accessed the application within an hour</a>. If not, I require them to log in again.
      </p>
    </div>
    <div class="code-block">
      <pre>
if ((<span class="2-d5">person.LastAccessTimestamp - DateTime.UtcNow).TotalMinutes > 60</span>)
{
    // Log out and send to the login screen.
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        There are a handful of other occurences like the examples above, where little bits of business logic against a <code>Person</code>'s properties are sprinkled about. Most of these bits feel so inconsequentually minor&mdash;simple, one-line constructions and statements&mdash;you might not even consider them to be &ldquo;business logic&rdquo; at all.
      </p>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        For instance, in the profile screen example, displaying a person's first and last name might not seem like <em>logic</em>, but it is&mdash;it represents a person's <a href="#" class="code-ref" data-code-ref="2-d6">full name</a>. I can push this bit of logic back to the <code>Person</code> class itself and name it something meaningful. 
      </p>
    </div>
    <div class="code-block">
      <pre>
public string <span class="2-d6">FullName</span>
{
  get
  {
    return FirstName + " " + LastName;
  }
}</pre>
    </div>
  </div>
  <div class="grid-left-code">
    <div class="content">
      <p>
        Likewise, the same can be done for the special format of the person's name in the subject line of the notification message. I could call this an <a href="#" class="code-ref" data-code-ref="2-d7">abbreviated name</a>.
      </p>
    </div>
    <div class="code-block">
      <pre>
public string <span class="2-d7">AbbreviatedName</span>
{
  get
  {
    return FirstName + " " + LastName.Substring(0,1) + ".";
  }
}</pre>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        Back on the profile screen, I can move the check for whether a person is an admin or owner as a property of the <code>Person</code> instead. In this case, the check is answering the question, "Does this person have administrative access?". <a href="#" class="code-ref" data-code-ref="2-d8"><code>HasAdminAccess</code> is a sound name</a> for this new property.
      </p>
    </div>
    <div class="code-block">
      <pre>
public bool <span class="2-d8">HasAdminAccess</span>
{
  get
  {
    return Role == AccountRoleType.ADMIN || Role == AccountRoleType.OWNER;
  }
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        The application access logic against the <code>Person</code> object within the security class can be pushed back to the class in a couple of ways. Here's that conditional statement again.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
if ((person.LastAccessTimestamp - DateTime.Now).TotalMinutes > 60)...
</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        There are a few ways I could go about moving this logic. The entire statement is asking if the person has been idle for more than 60 minutes, so I could take this entire statement and turn it into <a href="#" class="code-ref" data-code-ref="2-d9">a boolean property off <code>Person</code> like so</a>:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public bool <span class="2-d9">HasPersonBeenIdleForMoreThan60Minutes</span>
{
  get
  {
    return person.LastLoggedIn - DateTime.Now).TotalMinutes > 60;
  }
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        This cleans up <em>all</em> of the logic from the security method. But, the name feels way too specific. If someone were just inspecting the <code>Person</code> class, they might ask why such a specific property exists. In addition, if I change the requirements around the idle time, I might easily forget to change the name of the property. 
      </p>
      <p>
        I don't like these tradeoffs. In this case, I'd rather pull back on the specificity of the property so it has a better chance of being reused and maintained well over time.
      </p>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        For instance, I could push <em>just</em> the calculation of the idle minutes into the object and call this property <code>MinutesIdle</code>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public int MinutesIdle
{
  get
  {
    return (person.LastAccessTimestamp - DateTime.Now).TotalMinutes;
  }
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Or, I could convert the logic to a method and let the caller <a href="#" class="code-ref" data-code-ref="2-d9-1">pass in the idle minutes</a> to compare.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public bool IdleLongerThanMinutes(<span class="2-d9-1">int minutes</span>)
{
  return (person.LastAccessTimestamp - DateTime.Now).TotalMinutes > minutes;
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        These two examples are both decent options. But, I like the first option&mdash;it feels more straightforward and reads more coherently.
      </p>
      <p>
        With these updates, the <code>Person</code> class now evolves into something a lot more powerful. Here's what the full class now looks like with these additional, well-named properties.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
<pre>
public class Person
{
    public string FirstName;
    public string LastName;
    public DateTime LastLoggedIn;
    public AccountRoleType Role;
    
    public string FullName
    {
      get
      {
        return FirstName + " " + LastName;
      }
    }  
    
    public string AbbreviatedName
    {
      get
      {
        return FirstName + " " + LastName.Substring(0,1) + ".";
      }
    } 
    
    public bool HasAdminAccess
    {
      get
      {
        return Role == AccountRoleType.ADMIN || 
               Role == AccountRoleType.OWNER;
      }
    } 
    
    public int MinutesIdle
    {
      get
      {
        return (person.LastAccessTimestamp - DateTime.Now).TotalMinutes;
      }
    } 
    ...
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
       <p>
        By moving this logic into the <code>Person</code> class, it's now easier to DRY up my codebase. There will likely be other places that require displaying a person's full name or knowing whether they have administrative privileges. Those answers are already baked into the object itself.
      </p>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        Besides reuse, the biggest gain comes from the improved readability of my code. Here's how the improved implementations look like. In my HTML markup, the business logic visually competes far less with the HTML around it.
      </p>
    </div>
    <div class="code-block">
<pre>
&lt;div&gt;
  &lt;h2&gt;@authedPerson.FullName&lt;/h2&gt;
  @if (authedPerson.HasAdminAccess)
  {
      &lt;a href="..."&gt;Edit&lt;/a&gt; | &lt;a href="..."&gt;Cancel&lt;/a&gt;
  }
&lt;/div&gt;</pre>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        The subject of the email notification can also be interpreted with one glance. You don't spend time focusing on the details of how the person's name is being displayed anymore.
      </p>
    </div>
    <div class="code-block">
<pre>
var subject = person.AbbreviatedName + " added a comment";</pre>
    </div>
  </div>
  <div class="grid-right-code">
    <div class="content">
      <p>
        Finally, the conditional check on the person's login date can be understood instantly, instead of having to parse (even if for a brief moment) through the date math.
      </p>
    </div>
    <div class="code-block">
<pre>
if (person.MinutesIdle > 60)
{
  // Log out and send to the login screen.
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        The best part of this work is that, once you get accustomed to the game, it's not a heavy effort. It becomes a bit addictive. You can make these simple refactorings quickly and you can stop whenever the time you've devoted is up (or your manager's come back from lunch).
      </p>
      <p>
        Keep hunting for places where you can corral bits of logic into meaningful names, whether as standalone properties or back into the objects they derived from. It will do wonders to the clarity of your code.
      </p>
    </div>
  </div>
</div>


<div class="chapter" id="ch-surfacing-parameters">
  <div class="grid-content">
    <div class="content">
      <h2>Surfacing Method Parameters</h2>
      <p class="emphasis">
        When you think about it, methods are an odd-looking thing. 
      </p>
      <p>
        The more parameters a method requires, the harder it is to understand what that method does without digging into its definition. 
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
void Update(int id, string name, string address, int status...)</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        You can get around this mess by rounding up all of these parameters <a href="#" class="code-ref" data-code-ref="4-d0">into a single object</a> and passing it to the method. 
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
void Update(<span class="4-d0">UpdateParams params</span>) { ... }</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Sure, this approach tidys your code up, but it doesn't help you understand what the method actually <em>does</em>. This is when I like to look for ways I can push more meaning into the method name. Here's an example I stumbled upon recently.
      </p>
      <hr />
      <p>
        For years, DoneDone has only allowed customers the option to cancel an account immediately&mdash;it was instantaneous and irreversible. 
      </p>
    </div>
  </div>

  <div class="grid-right-code">
    <div class="content">
      <p>
        I have a method off of a billing repository class that's responsible for invoking the cancellation when requested. The guts of the method are involved, but <a href="#" class="code-ref" data-code-ref="4-d1">the method signature</a> is about as simple a read as you can imagine.
      </p>
    </div>
    <div class="code-block">
      <pre>
public class BillingRepository
{
  <span class="4-d1">public void CancelAccount(int account_id)</span> { ... };
  ...
}</pre>
    </div>
  </div>
  
  <div class="grid-content">
    <div class="content">
      <p>
        Over the years, we've had customers who've wanted to cancel their account at the end of their term which could be several months out. Rather than remembering to cancel their account in a few months, they wanted the account to automatically cancel on the last day of their term. 
      </p>
      <p>
        I start implementing this by tacking on a parameter to <code>CancelAccount()</code>. Since there are now two cancellation options, cancelling immediately <em>or</em> at the end of their current billing period, I choose the simplest parameter type that fills the need, the trusty boolean. 
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="4-d11">I decide to name it <code>cancel_at_period_end</code></a>. Now, I can pass in <code>true</code> to handle this new special case, and <code>false</code> to handle the original case.
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public void CancelAccount(int account_id, <span class="4-d11">bool cancel_at_period_end</span>);
</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
       After I've implemented the new code to handle the update, I then update <a href="#" class="code-ref" data-code-ref="4-d12">all existing references</a> to this method that handle the immediate cancellations.
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
      <pre>
_billing_repository.CancelAccount(account_id, <span class="4-d12">false</span>);
</pre>
    </div>
  </div> 

  <div class="grid-content">
    <div class="content">
      <p>
        But something doesn't feel right about this method signature.
      </p>
      <p>
        At a glance, it's hard to tell what the <code>false</code> parameter means. Having just written the updates, it makes sense to me now. But it won't to someone else (or to myself in a few days). They'll have to look at the method signature and perhaps even drill into the method to be sure. 
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="4-d2">I add a comment above each call to <code>CancelAccount()</code></a> for clarity.  It also helps differentiate between the new code I'll be adding later to handle the additional option of canceling at the end of the period.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
<span class="4-d2">// Cancel the account immediately...</span>
_billing_repository.CancelAccount(account_id, false);</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        <em>Better</em>. But comments never age well. The method call still feels strange. The standard cancellation case (canceling immediately) accepts the <code>false</code> parameter. Passing in <code>false</code> as the default just feels odd&mdash;It's as if I have to suppress something to perform the <em>default</em> action.
      </p>
      <p>
        I can get around this pretty quickly though. Since I'm working with a boolean parameter, I can change its meaning so that the standard case passes in <code>true</code> and update my code accordingly.
      </p>
    </div>
  </div>

  <div class="grid-right-code">
    <div class="content">
      <p>
        <a href="#" class="code-ref" data-code-ref="4-d3">I swap the <code>cancel_at_period_end</code> parameter with <code>cancel_now</code></a> and <a href="#" class="code-ref" data-code-ref="4-d4">modify the implementation</a>.
        Now, the default case passes in <code>true</code>. 
      </p>
    </div>
    <div class="code-block">
<pre>
public void CancelAccount(int account_id, <span class="4-d3">bool cancel_now</span>);

...

// Cancel the account immediately...
_billing_repository.CancelAccount(account_id, <span class="4-d4">true</span>);</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        But, I've introduced a more onerous problem. By simply reading the <code>CancelAccount()</code> method signature, I can't quite tell what passing in <code>false</code> would do. Would it cancel in a day? In a month? At the end of the period? 
      </p>
      <p>
        At this point, I've exhausted my options with the boolean parameter. While it allows for both options, the options aren't clear from the method signature.
      </p>
      <p>
        I often find this is the case with booleans when the concept it describes has two cases but the options aren't really <em>opposites</em>. That's the case here&mdash;the natural opposite of <code>cancel_now</code> isn't <code>cancel_at_period_end</code> in the way the natural opposite of <code>open</code> is <code>closed</code>.
      </p>
      <p>
        <a href="#" class="code-ref" data-code-ref="4-d5">I could try introducing an enumerated value instead</a>.
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
    <pre>
<span class="4-d5">enum CancelType 
{
  NOW,
  AT_PERIOD_END
}</span>
...

public void CancelAccount(int account_id, <span class="4-d5">CancelType cancel_type</span>);

...

_billing_repository.CancelAccount(account_id, <span class="4-d5">CancelType.NOW</span>);</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        This is an improvement. On the plus side, I've gotten rid of the ambiguity issues I had with the boolean parameter. It also leaves me better positioned to introduce additional cancelation types in the future.
      </p>
      <p>
        However, this just doesn't feel like one of those features we'd continually augment in the near future. There just aren't that many variations of canceling DoneDone that would make sense. And, now I've introduced a new type as well as a new parameter.
      </p>
      <p>
        I ultimately decide to simplify things. I create two distinct cancelation methods and convey the type of cancelation in the <em>method names</em>. 
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
    <pre>
public void CancelAccountNow(int account_id);
public void CancelAccountAtPeriodEnd(int account_id);</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        With this update, the standard and unique cancelation implementations both read clearly. There's zero ambiguity in either what the method does or what the parameters mean.
      </p>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        I also get an additional benefit. Breaking the method out into two methods allows me to separate the implementations of each. In the original approach, I'd have to do something like this.
      </p>
    </div>
  </div>

  <div class="grid-left-code">
    <div class="content">
      <p> 
        The method body would not only be much longer, but it would have more than one responsibility. Breaking the methods apart not only clarify their use, but will make finding and updating their implementations easier down the road.
      </p>
    </div>
    <div class="code-block">
<pre>
void CancelAccount(int account_id, bool cancel_at_period_end)
{
  if (cancel_at_period_end)
  {
    // Implementation for canceling at period end
  }
  else
  {
    // Implementation for canceling immediately
  }
}
</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <hr />
      <p>
        I find a similar opportunity arises when <code>null</code> values are passed to a method. Usually, it's a sign that a new method name ought to be created to handle the passing of <code>null</code> to the original method.
      </p>
      <p>
        In DoneDone, I have a series of "bulk edit" methods that live in a services layer. Each accepts a list of <code>issue_ids</code> and performs some action on the issue they represent. One of these is a function to bulk update the issues' due dates. 
      </p>
      <p>
        Here's the abbreviated signature. <em>(Due dates are optional&mdash;hence the nullable <code>DateTime?</code> object representing the due date in the parameter list).</em>
      </p>
    </div>
  </div>
  
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public void UpdateDueDates(List&lt;long&gt; issue_ids, DateTime? due_date, ...);</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        Crawling up to the application layer, here's where <a href="#" class="code-ref" data-code-ref="4-d6">I call the bulk edit due date method</a> based on the user's input:
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
<pre>
switch (input.ActionChangeType)
{
  case BulkActions.UPDATE_DUE_DATE:
    <span class="4-d6">_issues_service.UpdateDueDates(input.IssueIDs, DateTime.Parse(input.Value),...);</span>
    break;
    ... 
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        In a recent feature update, we wanted to explicitly add an option to <em>remove</em> due dates from all issues. Because the <code>UpdateDueDates()</code> method already gives the option to pass in a <code>null</code> value, <a href="#" class="code-ref" data-code-ref="4-d7">the update is straightforward</a>:
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
<pre>
switch (input.ActionChangeType)
{
  case BulkActions.UPDATE_DUE_DATE:
    _items_service.UpdateDueDates(input.ItemIDs, DateTime.Parse(input.Value), ...);
    break;
        
  <span class="4-d7">case BulkActions.REMOVE_DUE_DATE:
    _items_service.UpdateDueDates(input.ItemIDs, null, ...);
    break;</span>
    ... 
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        But, explicitly passing <code>null</code> makes the code less readable. When I  revisit this line of code down the road, I have to trickle into the method to be certain of what <code>null</code> refers to. So why not eliminate the need altogether?
      </p>
      <p>
        Back on the service layer, I create a new method specifically for removing due dates that wraps the original <code>UpdateDueDates()</code> method. And once again, I can give it a <a href="#" class="code-ref" data-code-ref="4-d8">more meaningful name</a>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
  <pre>
public void <span class="4-d8">RemoveDueDates</span>(List&lt;long&gt; issue_ids, ...)
{
  UpdateDueDates(issue_ids, null, ...);
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        With this small addition, I can tidy up the application layer code. In context, <a href="#" class="code-ref" data-code-ref="4-d10">the two actions around due dates are now much easier to parse</a>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
<pre>
switch (input.ActionChangeType)
{
  case BulkActions.UPDATE_DUE_DATE:
    <span class="4-d10">_items_service.UpdateDueDates(input.IssueIDs, DateTime.Parse(input.Value), ...);</span>
    break;
        
  case BulkActions.REMOVE_DUE_DATE:
    <span class="4-d10">_items_service.RemoveDueDates(input.IssueIDs, ...);</span>
    break;
    ... 
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <hr />
      <p>
        In both examples, adding a <em>new</em> method rather than relying on the parameters of an existing method were fairly easy decisions. In both cases, there was only one variant to the parameters, requiring one additional method.
      </p>
      <p>
        If the amount of variations are small (say, three or less), and these variations are unlikely to change over time, surfacing parameters into method names makes a whole lot of sense to improve your code readability.
      </p>
    </div>
  </div>
</div>

<div class="chapter" id="ch-shape-of-code">
  <div class="grid-content">
    <div class="content">
      <h2>The Shape of Code</h2>
      <p class="emphasis">
        Code has a certain <em>shape</em> to it. It's spacing. The indentations. Where line breaks are made. All of this stuff matters.
      </p>
      <p>
        Good shape makes code easier&mdash;and more enjoyable&mdash;to read. So, at times, my reason for naming something is unapologetically superficial: It might have more to do with the code's shape than the meaning of the name.
      </p>
      <p>
        Consider this simple <code>for</code> loop.
      </p>
    </div>
  </div>

  <div class="grid-right-code">
    <div class="content">
      <p>
        To me, this code has good shape. The importance of the variables are roughly equal to their size. When I read this code, it doesn't take me long to figure out that there is a <a href="#" class="code-ref" data-code-ref="5-d1"><code>tokens</code> array</a>, and <a href="#" class="code-ref" data-code-ref="5-d2">used tokens</a> in that array are added to <a href="#" class="code-ref" data-code-ref="5-d3">a <code>usedTokens</code> list</a>. 
      </p>
    </div>
    <div class="code-block">
      <pre>
for (int i=0; i < <span class="5-d1">tokens</span>.length; i++)
{
  if (<span class="5-d2">tokens[i].Used</span>)
  {
    <span class="5-d3">usedTokens.Add(tokens[i]);</span>
  }
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        Here's that same code block again with one name change. Instead of using the generic variable name <code>i</code>, I substitute it with a much more precise name, <a href="#" class="code-ref" data-code-ref="5-d4"><code>curIndexOfTokenArray</code></a>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
for (int <span class="5-d4">curIndexOfTokenArray</span>=0; <span class="5-d4">curIndexOfTokenArray</span> < <span class="5-d5">tokens</span>.length; <span class="5-d4">curIndexOfTokenArray</span>++)
{
 if (<span class="5-d5">tokens</span>[<span class="5-d4">curIndexOfTokenArray</span>].Used)
 {
   <span class="5-d5">usedTokens</span>.Add(<span class="5-d5">tokens</span>[<span class="5-d4">curIndexOfTokenArray</span>]);
 }
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        If I think only in terms of clarity, then the code should be an improvement. Certainly,  
        <a href="#" class="code-ref" data-code-ref="5-d4"><code>curIndexOfTokenArray</code></a> is clearer than <code>i</code>. But, is it <em>better</em>? 
      </p>
      <p>
        While the current index is a critical anchor of a <code>for</code> loop, representing it in a verbally meaningful way isn’t. For one thing, an index is common to <em>every</em> kind of <code>for</code> loop. In addition, it's scope is small&mdash;it only exists within a few lines inside the loop. If someone were really confused about the variable name, they only need to look around a small visual radius to get familiarized.
      </p>
      <p>
        The stars of the show here ought to be the <code>tokens</code> array and <code>usedTokens</code> list. Adding more description to <code>i</code> brings a peripheral stage crew member into the spotlight. The lines are altogether more difficult to digest&mdash;a whole lot of verbosity to explain something quite simple.
      </p>
      <p>
        The original version values the shape of the entire statement over the specificity of the variable name. There are certain times where this is a better trade-off. This is one of them.
      </p>
      <hr />
      <p>
        Here’s another example. In DoneDone, <code>systemTimeZones</code> represent a collection of objects each describing a time zone. The method below loops through this collection, then extracts time zone information to build a list of <code>DropDownComponents</code> while marking the passed-in time zone as <code>Selected</code>:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
<pre>
public List&lt;DropDownComponent&gt; BuildTimeZonesDropDownList(string selectedTimeZone)
{
  var result  = new List&lt;DropDownComponent&gt;();
  var systemTimeZones = TimeZoneInfo.GetSystemTimeZones();

  foreach (var systemTimeZone in systemTimeZones)
  {
    var comp = new DropDownComponent(systemTimeZone.Id, systemTimeZone.DisplayName);

    if (systemTimeZone.Id == selectedTimeZone)
    {
      comp.Selected = true;
    }

    result.Add(comp);
  }

  return result;
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        The issue with the shape of this code is how repetitive some of the variable names look. There are several names in this method that all look similar at a glance:
      </p>
      <ul>
        <li>The <code>systemTimeZones</code> collection</li>
        <li>The <code>systemTimeZone</code> object scoped in the <code>foreach</code> loop</li>
        <li>The <code>selectedTimeZone</code> parameter</li>
        <li>The <code>GetSystemTimeZones()</code> method call.</li>
      </ul>
      <p>
        Scenarios like these are tricky because each name, in isolation, is appropriately descriptive. No single name is egregiously lengthy, misleading, or overly detailed. 
      </p>
      <p>
        The problem, however, is when we step back and read the method as a whole. It reminds me a lot of the lines of a Dr. Suess story. One of my kids&rsquo; favorites is <em>Hop On Pop</em>, which begins:
      </p>
      <blockquote>
        UP PUP - Pup is up.<br />
        CUP PUP - Pup in cup.<br />
        PUP CUP - Cup on pup.<br />
      </blockquote>
      <div class="quoter">Dr. Seuss, <em>Hop on Pop</em></div>
      <p>
        The lines of Dr. Seuss, of course, are intentionally dizzying. My son loves to get lost in the pattern of the words and giggles at the absurdity of its rhythm. But, reading dizzying code at 5pm isn&rsquo;t that fun. For this, I need to make some name improvements.
      </p>
      <p>
        The most immediate and impactful name change I can make is with the name of the <code>systemTimeZone</code> object. It appears four times within the method whereas no other similarly named construct appears more than twice. Also, because its reach is small (only scoped to the <code>foreach</code> loop), I can get away with a less descriptive name without doing much harm to the reader’s understanding. 
      </p>
      <p>
        I try <a href="#" class="code-ref" data-code-ref="5-d6">reducing <code>systemTimeZone</code> to something shorter, like <code>tz</code></a>:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
<pre>
public List&lt;DropDownComponent&gt; BuildTimeZonesDropDownList(string selectedTimeZone)
{
  var result  = new List&lt;DropDownComponent&gt;();
  var systemTimeZones = TimeZoneInfo.GetSystemTimeZones();

  foreach (var <span class="5-d6">tz</span> in systemTimeZones)
  {
    var component = new DropDownComponent(<span class="5-d6">tz</span>.Id, <span class="5-d6">tz</span>.DisplayName);

    if (<span class="5-d6">tz</span>.Id == selectedTimeZone)
    {
      component.Selected = true;
    }

    result.Add(component);
  }

  return result;
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        I like this change already. Now, the details of the <code>foreach</code> loop are much easier to scan. In addition, all of the other similarly-named constructs benefit. They're given more room so that the similarity in their names aren’t as distracting on the eyes as they were before.
      </p>
      <p>
        Just like in the prior example, the variable <code>tz</code> feels sized appropriately. Conceptually, a small name like <code>tz</code> feels like just one element in a longer-named collection like <code>systemTimeZones</code>. These are the kinds of subtle visual cues that all lend themselves to good code shape.
      </p>
      <p>
        Next, I decide to <a href="#" class="code-ref" data-code-ref="5-d71">pare down the variable <code>systemTimeZones</code> to just <code>timeZones</code></a>. I originally named this list <code>systemTimeZones</code> to follow how the .NET framework named the get method I'm using (<code>GetSystemTimeZones()</code>). But, the word <em>system</em> doesn't add any helpful meaning here. This change also helps better <a href="#" class="code-ref" data-code-ref="5-d72">differentiate it from the <code>selectedTimeZone</code>
        variable</a> used inside the <code>foreach</code> loop.
      </p>
    </div>
  </div>
 <div class="grid-code-only">
    <div class="code-block">
      <pre>
public List&lt;DropDownComponent&gt; BuildTimeZonesDropDownList(string selectedTimeZone)
{
  var result  = new List&lt;DropDownComponent&gt;();
  var <span class="5-d71">timeZones</span> = TimeZoneInfo.GetSystemTimeZones();

  foreach (var tz in <span class="5-d71">timeZones</span>)
  {
    var component = new DropDownComponent(tz.Id, tz.DisplayName);

    if (tz.Id == <span class="5-d72">selectedTimeZone</span>)
    {
      component.Selected = true;
    }

    result.Add(component);
  }

  return result;
}
</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        I could go further and rename the other variables more uniquely, but I don't feel it's necessary. When I read the updated method, I don't feel that dizzying effect of all those similarly named variables that I did earlier. Mission accomplished.
      </p>
      <hr />
      <p>
        In DoneDone, there are places where I write code to build up larger segments of text. For instance, I use a <code>StreamWriter</code> to generate documentation for our API and a <code>StringBuilder</code> to write lines of dynamic text into an email object.
      </p>
      <p>
        Here's a case where I've used a <code>Document</code> object to build up our search catalog. The search catalog library I'm using is a port of the well-known Java search library <em>Lucene</em>, so naturally, a name like <code>lucene_document</code> feels appropriate here. Here's a bit of the code snippet that builds
        an instance of <code>Document</code> before it's added to the search catalog:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
var lucene_document = new Document();

lucene_document.Add(new Field(_FIELD_item_event_id, item_event.ItemEventID...);
lucene_document.Add(new Field(_FIELD_item_id, item_event.ItemID....);
lucene_document.Add(new Field(_FIELD_project_id, item_event.ProjectID...);
lucene_document.Add(new Field(_FIELD_creator_id, item_event.CreatorID...);
lucene_document.Add(new Field(_FIELD_created_on, item_event.CreatedOn...);
lucene_document.Add(new Field(_FIELD_is_convo_thread, item_event.IsConvoThread...);
lucene_document.Add(new Field(_FIELD_is_non_convo_creation, item_event.IsNonConvoCreation...);
lucene_document.Add(new Field(_FIELD_item_title, item_event.Title...);
lucene_document.Add(new Field(_FIELD_item_event_desc, item_event.PlainTextDescription...);
      </pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Is it specific? Yes. But, at a glance, the name <code>lucene_document</code> is overwhelming. It pushes the interesting part of the code further to the right without adding much information. I decide to trim this name down to something much smaller, like <code>doc</code>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
var doc.Add = new Document();

doc.Add(new Field(_FIELD_item_event_id, item_event.ItemEventID...);
doc.Add(new Field(_FIELD_item_id, item_event.ItemID....);
doc.Add(new Field(_FIELD_project_id, item_event.ProjectID...);
doc.Add(new Field(_FIELD_creator_id, item_event.CreatorID...);
doc.Add(new Field(_FIELD_created_on, item_event.CreatedOn...);
doc.Add(new Field(_FIELD_is_convo_thread, item_event.IsConvoThread...);
doc.Add(new Field(_FIELD_is_non_convo_creation, item_event.IsNonConvoCreation...);
doc.Add(new Field(_FIELD_item_title, item_event.Title...);
doc.Add(new Field(_FIELD_item_event_desc, item_event.PlainTextDescription...);
      </pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Now, the code feels less cluttered. The interesting parts are quicker to get to. It's much easier to consume.
      </p>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <hr />
      <p>
        When you edit names, you shouldn't look at them in isolation. That habit can drive naming decisions that don’t actually benefit the overall readability of the surrounding code. 
      </p>
      <p>
        Instead, look at the context in which these names live. Find out what’s making a section of code difficult to read and solve the larger problem. It might be a more descriptive variable name, but it might also be a terse one. Let the full context drive those decisions.
      </p>
      <p>
        In the previous examples, I didn't value the precision of certain variable names as much as I did the shape of the lines around them, particularly because the scope of those variables was small or the extra precision didn't add much context.
      </p>
      <p>
        When editing prose, you read whole sentences and paragraphs to get a sense of readability and style. I find code writing to be similar.
      </p>
    </div>
  </div>
</div>

<div class="chapter" id="ch-when-opposites-dont-attract">
  <div class="grid-content">
    <div class="content">
      <h2>When Opposites Don't Attract</h2>
      <p class="emphasis">
        Usually, the English language has enough breadth that most words have a clear opposite.
      </p>
      <p>
        For a piece of functionality that allows you to move a file out of the trash, you don't have to say <em>undelete</em>; <em>Restore</em> makes perfect sense. It's clear that a file that can be restored has already been deleted or removed.
      </p>
      <p>
        But, sometimes finding the opposite isn't always straightforward.
      </p>
      <hr />
      <p>
        There's this concept in the new DoneDone called <em><a href="https://www.youtube.com/watch?v=Z7rkxgq6-Ac">Workflows</a></em>. A workflow defines a series of statuses available for a task. A typical workflow might have statuses like "Open", "In Progress", "Not Reproducible", "Closed" and so forth. We let users create workflows to tailor them to their particular business processes. 
      </p>
      <p>
        A workflow has its own status too. It starts as <em>unpublished</em>. When you're ready to use the workflow on a project, you must <em>publish</em> it. Simple enough.
      </p>
      <p>
        But, once a workflow is published, you can still <em>unpublish</em> the workflow. There are a few caveats to this, so I decide to wrap this logic inside of a convenient little method inside the <code>Workflow</code> class. My first attempt at a method name is <code>IsWorkflowUnpublishable()</code>.
      </p>
      <p>
        Quickly, I realize there's something unsavory about this name. Someone could easily mistake this name to mean that a workflow <em>cannot be published</em> rather than that a workflow <em>can be unpublished</em>. Those are, indeed, two very different things.
      </p>
      <p>
        The problem is that there just isn't a good adjective that means the opposite of published. <em>Draft</em> might be the best way to describe this concept. It's something I've seen before in blogging tools for instance. But a method name like <code>IsWorkflowDraftable()</code> or <code>IsWorkflowAbleToBeInDraftMode()</code> feels like I'm headed in the wrong direction fast.
      </p>
      <p>
        In cases like these, I try to look for a completely different angle to the name. After staring at my options for a few minutes, I realize the obstacle lies with the initial word <em>is</em>. It forces me into having to come up with an adjective to describe the state of the workflow I want to achieve&mdash;and there aren't any good ones that make the method name read clearly.
      </p>
      <p>
        Instead of starting the name with the adjective-requiring "is", I start with the verb-requiring "can." <code>CanUnpublishWorkflow()</code>
      </p>
      <p>
        Now I might be onto something! Notice I still use the word <em>unpublish</em>, but as a verb the intent is no longer ambiguous. It's clear we are checking whether this <em>workflow can be unpublished</em> as opposed to checking whether the <em>workflow can't be published</em>.
      </p>
      <hr />
      <p>
        If the opposite version of a name makes your method ambiguous, instead of pushing harder on finding a different name, see if you can reword the method altogether. You might already have all the pieces you need without knowing it.
      </p>
    </div>
  </div>
</div>

<div class="chapter" id="ch-tautologous-name-trap">
  <div class="grid-content">
    <div class="content">
      <h2>The Tautologous Name Trap</h2>
      <p class="emphasis">
        The French philosopher René Descartes once said &ldquo;I am, therefore I am.&rdquo; What makes for a great philosophical statement to ponder also makes for an unhelpful line of code to read.
      </p>
      <hr />
      <p>
        I'm working on a piece of code that processes incoming emails for DoneDone. One of its responsibilities is to send an auto-response email back to the original sender if certain conditions are met.
      </p>
      <p>
        In the first iteration of this feature, I send the auto-response only if the  email was received outside of a company's office hours. 
        I've written a method named <code>isCurrentlyOutsideOfficeHours()</code> which queries the company's work hours and figures out if the current time falls outside of them. 
      </p>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        In my incoming email handler, I call this method to determine if DoneDone should send an auto-response.
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
      <pre>
if (isCurrentlyOutsideOfficeHours()) 
{
  sendAutoResponse();
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        The method name <code>isCurrentlyOutsideOfficeHours()</code> makes the conditional statement read coherently. Even a non-programmer can read the statement above and guess what it does: "If it is currently outside the office hours, then send an auto-response."
      </p>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Suppose&mdash;later on&mdash;we decide to allow users to configure company holidays as well as office hours. This way, the auto-response will always be triggered during a company holiday regardless of the time of day.
      </p>
    </div>
  </div>

  <div class="grid-left-code">
    <div class="content">
      <p>
       Back under the hood, I add the new functionality. Now, the check for whether to send the auto-response has <a href="#" class="code-ref" data-code-ref="7-d1">this new condition</a>.
      </p>
    </div>
    <div class="code-block">
      <pre>
if (isCurrentlyOutsideOfficeHours() <span class="7-d1">|| isCompanyHoliday()</span>) 
{ 
  sendAutoResponse(); 
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        Because I've added more complexity to the auto-response logic, I might consider pushing the conditional expression into its own method, then calling the new method in place of the expression. At first, a name like <code>shouldSendAutoResponse()</code> sounds completely sensible. Here's what that would look like:
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
      <pre>
private bool shouldSendAutoResponse()
{
  return isOutsideOfficeHours() || isCompanyHoliday();
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        With a new property extracted, I can replace the original conditional so my code is tidy again. 
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
if (shouldSendAutoResponse()) 
{ 
  sendAutoResponse(); 
}</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        But, do you spot the new problem? Descartes might. The statement, while tidy, has lost all of its meaning. Of course we send the auto-response if we should send the auto-response!
      </p>
      <p>
        When you read the conditional in isolation, you don't know <em>why</em> the auto-response is being sent. You need to trickle into the <code>shouldSendAutoResponse()</code> method to find out. The extraction doesn't give us better comprehension&mdash;it just tucks away some logic.
      </p>
      <p>
        I find this happens a lot with these quick extraction exercises. My immediate inclination is to name the newly extracted property after the <em>outcome</em> of the conditions being met rather than the <em>meaning</em> of the conditions. I name the property after the <em>effect</em> rather than the <em>cause</em>.
      </p>
      <p>
        Not only does this create tautalogous statements, but it's less likely I'll reuse the new construct somewhere else. At a glance, I wouldn't think to employ <code>shouldSendAutoResponse()</code> anywhere else besides the place in code where I want to send auto-responses. If I named the method after what's <em>causing</em> the sending of the auto-response, I better my chance of reuse later.
      </p>
      <p>
        So, why are we sending the auto-response? In this case, the cause of sending an auto-response message is because, quite simply, <em>the office is closed</em>. Let's try that.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
bool isOfficeClosed()
{
  return isOutsideOfficeHours() || isCompanyHoliday();
}

...

if (isOfficeClosed()) 
{ 
  sendAutoResponse(); 
}</pre>  
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
      The conditional now reads much more meaningfully. In addition, <code>isOfficeClosed()</code> is a method that has far more obvious applications than <code>shouldSendAutoReponse()</code> does. 
      </p>
      <hr />
      <p>
      Tautologous conditionals aren't necessarily bad, though. There are times where describing the <em>effect</em> is the cleanest option. Let's continue with this example. 
      </p>
      <p>
      Suppose that we introduce a few more conditions to determine whether to send an auto-response. Namely, we let an account toggle auto-responses altogether and we also want to exclude auto-responses to emails that are flagged as spam. My first step is to <a href="#" class="code-ref" data-code-ref="7-d2">augment the conditional</a> one more time.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
if (isOfficeClosed() <span class="7-d2">&& autoResponseEnabled && !_email.IsSpam</span>) 
{ 
  sendAutoResponse(); 
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        The conditional expression bloats up again&mdash;it seems ripe for packaging things up. But, I have trouble finding an elegant solution. Is there a meaningful name that could consolidate all (or some) of the expression <code>isOfficeClosed()</code>, <code>autoResponseEnabled</code>, and <code>!_email.IsSpam</code>? There doesn't appear to be a common relationship other than they all factor into sending an auto-response.
      </p>
    </div>
  </div>

  <div class="grid-left-code">
    <div class="content">
      <p>
        I can either leave things as is, or name the entire expression for what it affects. <a href="#" class="code-ref" data-code-ref="7-d3">In this case, I choose the latter</a>.
      </p>
      <p>
        I live with the <a href="#" class="code-ref" data-code-ref="7-d4">tautologous statement</a> to keep the code succinct, even though I'm unlikely to reuse this method elsewhere.
      </p>
    </div>
  <div class="code-block">
    <pre>
bool isOfficeClosed()
{
  return isOutsideOfficeHours() || isCompanyHoliday();
}

<span class="7-d3">bool shouldSendAutoResponse()
{
  return isOfficeClosed() && autoResponseEnabled && !_email.IsSpam;
}</span>

<span class="7-d4">if (shouldSendAutoResponse()) 
{ 
  sendAutoResponse(); 
}</span></pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <hr />
      <p>
        I make tradeoffs with names depending on how a section of code evolves. When I can find an apt name for the <em>cause</em>, I choose it. When I can't, I might decide that naming an extraction for its <em>effect</em> is still better than not extracting it at all.
      </p>
    </div>
  </div>
</div>


<div class="chapter" id="ch-names-are-fickle">
  <div class="grid-content">
    <div class="content">
      <h2>Names are Fickle</h2>
      <p class="emphasis">
        Keeping a codebase with well-intentioned names is often just about <em>remembering</em> to do so. 
      </p>
      <p>
        Everytime you make a change to a codebase, you have to consider the names of things over again. It's easy to leave working code as-is, without considering the debt you've just handed over the next reader. 
      </p>
      <hr />
      <p>
        Awhile back, I had a method that updated various pieces of account data:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public void UpdateAccountInfo(string accountName, int accountOwnerID, byte[] logoImage);</pre>
      </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        As you can probably tell by the signature, this method lets you change the name of the account, the owner of the account, and the logo tied to the account.
      </p>
      <p>
        At some point, it became advantageous to handle the uploading of the logo somewhere else. As part of this update, I pulled the <code>logoImage</code> parameter out of this method.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public void UpdateAccountInfo(string accountName, int accountOwnerID);</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        Down the road, we also allowed an account to have multiple owners. Since the change was fairly large, I decided it was best to manage owners in an entirely separate part of the application. Part of this update naturally required removing the <code>accountOwnerID</code> from this method.
      </p>
    </div>
  </div>

  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public void UpdateAccountInfo(string accountName);</pre>
    </div>
  </div>

  <div class="grid-content">
    <div class="content">
      <p>
        In the flurry of updating code, it's easy to leave the <code>UpdateAccountInfo()</code> method named as is. But, stripped of most of its original responsibilities, this method is much better named <code>UpdateAccountName</code>. That's all it's doing anymore. It also doesn't hurt to shorten the parameter <code>accountName</code> to just <code>name</code>, since it's obvious at this point what the parameter refers to.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public void UpdateAccountName(string name);</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <hr />
      <p>
        This change sounds obvious to make, but it's only because I've isolated the discussion of what changed to just this lone method&mdash;not the myriad of method additions, refactorings, and adjustments that come as a natural part of every kind of code change.
      </p>
      <p>
        When you’ve moved code around your application to get the pieces fitting just right, revisit how you’ve named the methods, properties, and classes that have undergone the facelift. Do these names still make sense? Do the comments around these methods still apply?
      </p>
      <blockquote>
        &ldquo;One of the biggest sins you can commit is to stop programming when it works.&rdquo;
      </blockquote>
      <div class="quoter">
        Brandon Rhodes, <a href="https://www.youtube.com/watch?v=YklKUuDpX5c">PyCon 2013</a>
      </div>
      <p>
        When you're in the same code daily, you might not even notice that the name of a variable or method is misleading because you're so familiar with it. But, to someone coming into the codebase fresh (or, if you happen to take a few weeks off and come back later), misleading names will be detrimental to their understanding of the system.
      </p>
      <p>
        There won't be a failed unit test or compiler warning telling us that a construct's name is no longer relevant. That's why they're so often left unchanged. So, remember to look for opportunties to tighten a construct's name everytime something changes about that construct. Nothing else will automatically remind you to do so.
      </p>
    </div>
  </div>
</div>

<div class="chapter" id="ch-abstracting-to-soon">
  <div class="grid-content">
    <div class="content">
      <h2>Abstracting Too Soon</h2>
      <p>
        [Combine with "The Wrong Abstraction" in book-on-naming-things?....system/inappemail method naming]
      <p>
        As I write code, I usually start with names that describe their constructs concretely before gradually iterating toward something more abstract. Proper abstractions need to be made at the right pace. Abstract too slowly and it will be the feature creep that steers the ship. Abstract too soon and the boat will soon be sinking under its own weight.
      </p>
<p>
[Maybe Sandi Metz bit here about championing the idea of duplicate code better than the wrong abstraction?]
</p>
<p>
Naming should also undergo the same kind of scrutiny. The gradual reshaping of our codebase also warrants constant re-evaluation of the names we give to the constructs in our code. 
</p>
<p>
It's taxing work. And I think it leads programmers (including myself) to abstract the meaning of a name too early in the process - a desparate attempt to get a name right, once and forever. But I've never found prematurely abstracting a name helpful. In fact, it often inflicts more pain than comfort, just like premature code abstraction does.
</p>
<hr />
<p>
I'm going through a refactoring in DoneDone's codebase to consolidate a few data objects that hold very similar kinds of information in slightly different ways. They all revolve around the history of actions applied to an issue.
</p><p>
Ultimately, the properties of these objects manifest in a few different places. On an issue's detail page, the collection of history for a single issue is written out from an <code>IssueDetailHistory</code> collection. On the activity dashboard, a list of history on all issues in a given day is extracted from a list of <code>ActivityHistory</code> items. When activity occurs on an issue, yet another "history" object is packaged up in a class with a list of emails to send to specific users. A mailing service unpacks the data and formats the right bits of information into emails.
</p><p>
Each of these objects look nearly identical. They all could derive from a single class, but they've all been written separately from each other over time. It's time to consolidate them.
</p><p>
After a fair amount of hair-pulling, I've reduced these classes into a single <code>IssueHistory</code> class that can support the needs of each of these three distinct use cases, and more going forward. This also gives me an opportunity to consolidate similar names in the old objects like <code>CreatedOn</code>, <code>CreatedDate</code>, or <code>CreateDate</code> into one consistent name (I like <code>CreatedOn</code>, for what it's worth).
</p><p>
In the process of the consolidation, I discover one particular string off of the old history object used by the mailing service. It's a terse description used as the beginning of the email subject, like "New fixer" or "Priority Update" or "Closed". (The rest of the subject is composed of the issue number and title). 
</p><p>
The dilemma I face here is what exactly to call this string. At present moment, it's <em>only</em> used by the mailing service and not by either the detail page or activity dashboard. But, since I've done all the pruning to get toward a single object, I feel compelled to come up with a name that can satisfy all future implementers.
</p><p>
My natural inclination is to call this something like <code>AbbreviatedAction</code>, especially because it juxtaposes nicely with the <code>Action</code> attribute that stores a more verbose description of the action ("John Doe was assigned to fix the issue" or "The priority was updated to Critical") I go with this name.
</p><p>
After a few days of refactoring the rest of the code, I find myself going back to this name a couple of times not entirely remembering what it's being used for. I even decide to comment the name to remind me it's only being used by the mailing service as part of the subject of the email. 
</p>
</div>
</div>
<div class="grid-code-only">
  <div class="code-block">
    <pre>
// Note: Only being used by the mailing service right now as part of the email subject, but I'm sure it will have other uses one day.
public string AbbreviatedAction
{
  get { … }
}
</pre>
</div>
</div>

 <div class="grid-content">
  <div class="content">
    <p>
Whenever I have to remind myself what a name means (and eventually surrender to the commenting devils) there's a good chance I've prematurely abstracted the name.
</p><p>
Instead of finding a name that simultaneously fits anything but nothing in particular, it's best I reduce the scope of the name's meaning to fit how it's being used right now. A name like <code>EmailSubjectAction</code> ends up working a lot better.
</p>
</div>
</div>
<div class="grid-code-only">
  <div class="code-block">
    <pre>
public string EmailSubjectAction
{
  get { … }
}
</pre>
</div>
</div>
 <div class="grid-content">
  <div class="content">
    <p>
Some might worry that a name that's too specific like this might hide the full capabilities of that construct. That, one day, I'll need the very thing that <code>EmailSubjectAction</code> brings to the table (a terse description of an issue action) for something entirely unrelated to email subjects and I will never realize it existed. Instead, I'll create a near-identical version of that construct and name it something else.
</p><p>
In my experience, I rarely find this to be the case. If I'm familiar enough with the codebase, I recall some part of it that replicates (or nearly replicates) what I'm trying to implement by thinking about the particular feature ("What I need is just like that first part of that subject line of the emails that are sent when issues are updated!") rather than the particular name of the relevant construct (<code>EmailSubjectAction</code>). The more specific name just helps me find where that construct lives, faster.
</p><p>
Others might argue that I really should move this particular property to its own class and inherit the <code>IssueHistory</code> class. This way, I can use this class specifically for the emailing case. But, to me, the additional overhead of managing another class just for the sanctity of keeping the name exposed only to those who need it isn't worth the tradeoff. I'm OK with exposing this property to the other use cases especially if it's the only one of its kind. If this starts becoming a theme with other properties, then I might sway the other way. But, it's too early now.
</p><p>
Once that construct is being used in multiple different ways, then I can justifies the broader name change. In my case, <code>AbbreviatedAction</code> may eventually be the best name one day, but only when its set of use cases warrants it.
</p>
</div>
</div>
</div>

<div class="chapter" id="ch-speaking-the-native-tongue">
  <div class="grid-content">
    <div class="content">
      <h2>Speaking the Native Tongue</h2>
      <p class="emphasis">People that write code today are often the same ones making business decisions or collaborating directly with clients.
      </p>
      <p>
        This makes it even more critical that programmers understand the business reasons behind their work. One of the best ways we can encourage this is to infuse the language of the business directly into our code.
      </p>
      <p>
        If I were building internal software to track the organizational aspects of a law firm, I'd want the names of the constructs in my software system to be as closely aligned to the words law professionals use to describe their own concepts. <code>PracticeAreas</code> instead of <code>Topics</code>. <code>PracticeGroups</code> instead of <code>Teams</code>. <code>Attorneys</code> and <code>Paralegals</code> instead of <code>Users</code>. This way, I don't have to make the mental mapping between what the client calls Concept X with what I call Concept Y.
      </p>
      <p>
        Business concepts can also dictate the kind of structures we introduce to a codebase. Consider this example.
      </p>
      <p>
        If I were building a patient management system for a medical clinic, I might define a doctor's patient list with a structure like <code>List&lt;Patient&gt;</code>. It seems reasonable enough. Plus, I get all the normal functions associated with a <code>List</code> out-of-the-box, like <code>Add()</code>, <code>Remove()</code>, <code>Count()</code> and so forth.
      </p>
      <p>
        But, doctors don't call these things patient lists, they call them patient <em>panels</em>. Doctors speak to how their "panels are full" or when new spots in their panel will open up. Knowing this, I'd opt to create a <code>Panel</code> class instead which houses the <code>List&lt;Patient&gt;</code> collection as its own property.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public class Panel
{
  public List&lt;Patient&gt; Patients;  
  ...
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>  
        Because medical professionals have defined a specific concept called panels, it's almost certain that there are specific attributes tied to a panel&mdash;it's not just a convenient alias to a collection of patients. 
      </p>
      <p>
        As it turns out, panels aren't just assigned to doctors, but to medical assistants and health educators. Panels also have a certain optimal number of patients (so that all clinicians generally see the same number of patients). Panels can have openings or be closed. It turns out there's a lot of other attributes tied to the concept of a panel. 
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
<pre>
public class Panel
{
  private List&lt;Patient&gt; _patients;  
  
  private Doctor _doctor;
  private HealthEducator _healthEducator;
  private List&lt;MedicalAssistant&gt; _medicalAssistants;
  
  private bool hasOpening;
  ...
}
</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>  
        To add a patient to a panel, my first attempt at a method signature might be something like:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
    <pre>
public class Panel
{
  public void Add(Patient p)
  {
    patients.Add(p);
  }
  ...
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Certainly, <code>Add</code> is clear, and it follows directly from the <code>Add()</code> method associated to the <code>List</code>. But, doctors usually talk about patients <em>subscribing</em> to a panel. So, <a href="#" class="code-ref" data-code-ref="10-d1"><code>Subscribe</code> is a far more fluent approach</a>.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
public class Panel
{
  public void <span class="10-d1">Subscribe</span>(Patient p)
  {
    patients.Add(p);
  }
  ...
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        These name and construct choices seem small at first. But, as the codebase grows and the functionality gets more complex, the benefits become more significant.
      </p>
      <p>
        By naming concepts in code the way in which software users would talk about them, we remove a layer of unnecessary interpretation. Our code becomes less foreign to people that aren't directly working with it. Software writers can have more productive discussions with other teams within the organization. And, most importantly, we have a better grasp of the business concepts we have to maintain.
      </p>
      <p>
        A> The law firm example has a particular place in my brain because many moons ago, I worked at a company that specialized in building software for law firms (websites, intranets, and "extranets").
      </p>
      <p>
        A> At some point, we did some pro-bono work for the CEO's old grade school by building their website and content management system. But, instead of building a custom database for them, we "leveraged" the existing database schema we'd been using for many of our corporate law client clients. I guess there were enough similarities in the organizational structures of a school that we could get by with our pre-built software for law firms.
      </p>
      <p>
        A> This, naturally, led to some pretty entertaining naming translations. The `tbl_Employees` table held teachers and students. A column normally reserved for law firm employee types was now re-purposed for the school. Teachers became attorneys; Principals became partners. The `tbl_PracticeAreas` table was repurposed for the course curriculum.
      </p>
      <p>
        A> It was funny to have to write code against a bunch of third-grade paralegals.
      </p>
      <p>
        A> Talk about Fowler's/Eric evans Ubiquitous Language concept? At least touch upon it. 
      </p>
      <p>
        Unearthing patterns is one of the most fundamental mental exercises in coding. When we can trivialize a procedure that once required a lot of thought into something seemingly automatic, we can move onto solving other problems. 
      </p>
      <p>
        On the other hand, automation can bias our thinking. We end up forcing a pre-conceived solution every time we encounter what feels like a similar problem without the careful examination we once gave it before we discovered a pattern. The reasoning becomes dogmatic&mdash;it fits this pattern so this must be the way forward!
      </p>
      <p>
        Let's call this phenomenon "pattern hypnosis." Even the task of naming can fall prey to this pattern hypnosis. I notice I fall into the trap quite frequently when naming tables in a relational database model.
      </p>
      <p>
        If you're familiar with relational data modeling, you'll know one of the more common modeling concepts is the associative table.
      </p>
      <p>
        An associative table's core characteristic is that it contains two or more foreign keys to tables that have a "many-to-many" relationship, like a table that links a <code>tbl_Students</code> table to a <code>tbl_Classes</code> table. A student enrolls in many classes and a class has many students. The associative table would hold the relationship between those two tables alongside any other data relevant to that relationship (like a student's current grade in that class).
      </p>
      <p>
        A common pattern is to name such an associative table by gluing the adjacent table names together. This approach usually creates a unique table name that's palatable. <code>tbl_StudentsClasses</code> feels like a reasonable name for this table. It reads decently.
      </p>
      <p>
        Let's take another example. I have a table that links a <code>tbl_Users</code> table with a <code>tbl_Accounts</code> table.  A single user can belong to many accounts and an account can have many users. If I'm blindly naming an associative table that links these two tables together, I'd call it <code>tbl_UsersAccounts</code>. 
      </p>
      <p>
        Down the road, I add other attributes to the model, like a date for when a user was added to the account. That column would fit naturally in the <code>tbl_UsersAccounts</code> table. But, saying "Nora's user account began on June 3rd, 2016" sounds obnoxiously technical. It sounds much more natural to say "Nora's membership began on June 3rd, 2016." 
      </p>
      <p>
        So, I decide to update the table name to <code>tbl_Memberships</code>. 
      </p>
      <p>
        Later on, I want to add a third association to the table&mdash;a relationship to a set of available roles. This way, I can model a particular user with an account and a level within the account (Nora has Gold status). If I'm blindly following convention, I'd name my table to something like <code>tbl_UsersAccountRoles</code>.
      </p>
      <p>
        Meanwhile, the name <code>tbl_Memberships</code> still holds up. "Nora has a gold-access membership to the Acme account." 
      </p>
      <p>
        This kind of pattern hypnosis isn't relegated to just table naming. Object-relational mappers usually map directly to tables, so it's common to see the same name patterns appear in data transfer or business domain objects as well.  A <code>UserPublication</code> class might be better served as a <code>Subscription</code> class. <code>CustomerProduct</code> could be a <code>PurchaseOrder</code>. <code>PassengerFlight</code>? A <code>Booking</code>.
      </p>
      <p>
        This isn't to say that the default pattern never works. Lots of times, it is the most sensible way to describe an association. But, in the end, to name things well, I sometimes have to fight the hypnosis of the easy route.
      </p>
    </div>
  </div>

</div>
</div>
</div>



<div class="chapter" id="ch-naming-to-teach">
  <div class="grid-content">
    <div class="content">
      <h2>Naming to Teach</h2>
      <p>
        I have a very simple thing to say about how code is taught. The more advanced you are, the more likely you teach the craft poorly. As you become more advanced in a field, more basic concepts in that field become so familiar that it becomes harder to recall what it was like before you understood those concepts. 
      </p>
      <p>
        Assuming you actually know how to ride a bike&mdash;and have known how to do so for years&mdash;imagine the feeling you had of getting on a bike for the very first time. You tried to pedal and keep the handlebars straight, but you <em>still</em> fell down. I can remember this struggle when I was five years old. 
      </p>
      <p>
        If I got on a bike today, I would have to fight my instincts to try to pedal and fall down. It would actually be <em>hard</em> for me to fall off my bike now. The old saying "it's like riding a bike" isn't just about something being intuitive; it's about how hard it is to recall the feeling of that thing not being intuitive.
      </p>
      <p>
        Having worked with object-oriented programming languages for over twenty years, to me, the concept of a class constructor is obvious&mdash;it's a method which instantiate an instance of the object a class defines. Like riding a bike.
      </p>
      <p>
        But, when I was first taught about class construction, I was at a complete and utter loss. The concept was one of those fancy italian racing bikes with those clip-on pedals. I was a mermaid. 
      </p>
      <p>
        Looking back, it was unclear to me because I couldn't differentiate a class definition from an instance of the class&mdash;that these were two entirely different things. I couldn't visualize "instantiation". Is this a term ever used outside of programming?
      </p>
      <p>
        A large part of the problem was how the concept was introduced. I recall seeing one of these example lines of code in my introductory class. While it's easy for me to understand now, I remember vividly the feeling of confusion staring at this kidn of code. I remember having to parse through it a dozen times to finally <em>get it</em>. The next day, it became completely foreign again.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
<pre>
Object myObject = new Object();
myObject.DoSomething();</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        A line of code like this has no relatable concept outside of the programming world to latch onto. The word <code>Object</code> appears three times in one line. It creates that dizzying effect I mentioned in <a href="#ch-shape-of-code">The Shape of Code</a>. A knowledgeable programmer knows that they each stand for something different.
      </p>
      <ul>
        <li>The first <code>Object</code> refers to the type of the instance we're instantiating.</li>
        <li>The second <code>Object</code> is part of the name of this instance <code>MyObject</code>.</li>
        <li>The third <code>Object</code> is invoking the constructor.</li>
        <li>The fourth <code>Object</code> is part of the now-instantiated instance <code>myObject</code>, which is now performing the very detailed action of <code>DoSomething()</code>.</li>
      </ul>
      <p>
      But, for a programming newbie, this made as much sense as this equally sensible line.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
Xy8lksp0 myXy8lksp0 = new Xy8lksp0();
myXy8lksp0.DoSomething();</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Some code writers will "improve" upon this example by introducing meaningless variable names&mdash;<code>foo</code>, <code>bar</code>, <code>baz</code>, and so forth.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
Object foo = new Object();
foo.DoSomething();</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        This helps rid some of the dizzying effects. At least the instance name is more readily discernable. But, the newbie is still left wondering what this all means. What is a <code>foo</code>? I'd come to find that it's intentionally meant to mean nothing specific--a way of ensuring the novice understands that the concept can be pplicable to nearly every kind of a "thing". 
      </p>
      <p>
        But, at such an early step in the process, concreteness is exactly what the novice needs. The mental bridge to the abstract is far easier to cross this way, than to immediately start with the abstract. 
      </p>
      <p>
        Then there are the "concrete" examples that are easy to visualize, but unrelatable to the vast majority of real programming tasks. This makes the bridge from the example to something a novice might actually need to do, still, a difficult one to cross. I see this in many writeups when demonstrating how an interface is used, with the classic example always revolving around domesticated household pets.
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
interface IAnimal
{
    string Speak();
}

class Dog : IAnimal
{
    public string Speak()
    {
        return "Bark!";
    }
}

class Cat : IAnimal
{
    public string Speak()
    {
        return "Meow!";
    }
}</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        The example is certainly _concrete_, but when's the last time you worked on a video game with anima superheroes or for a pet store supply chain? . Imagine a newbie attempting to parlay the knowledge gained from this example of interfaces into a generic integration engine or a file export tool. 
      </p>
      <p>
        It may be second nature for a seasoned programmer, but for someone who's just learning these new concept of inheritance and intefaces, it takes a large leap to correlate a method like `Speak()` with animals to `ExportFile()` with various file types. At the same time, it's not as if a newbie doesn't understand the concept that a document can be exported as a PDF, plain-text file, Word doc, and so forth.
      </p>
      <p>
        So, why not skip the animal stuff and just start with a more relatable example -- you know, the ones you find when you're trying to do things with _software_. Then, it's imperative to name the constructs in our examples as _concretely_ as possible. Let the novice anchor their understanding around something real. This will make the bridge to other similar examples easy to cross. With confidence and momentum behind their newfound knowledge, it will make the further reaching bridges quicker to cross as well.
      </p>
      <p>
        [Deitel and Deitel example of gradebook...concrete, and more real world -- we might be building some system...but still using myGradebook1 and myGradebook2]
      </p>
      <p>
        A better example of constructors and class instantiation may be something like this:
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
User requester = new User(username, password);
requester.AttemptLogin();</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Most all software these days require logins and users. This would be an instantly relatable example to the vast majority of novices. 
      </p>
      <p>
        Nearly every programming book I know will start with an example of a default constructor method that always has no parameters. Now, I know technical authors do this to prove the point that a constructor's unique quality -- the thing that differentiates it from any other method of a class -- is that it instantiates the object. We want to show the newbie that the mere act of calling this thing -- the one with the same name as the class but with two parentheses at the end -- creates an instance. Adding parameters to that method would just get in the way of that point.
      </p>
      <p>
        But, I remember thinking that for some reason, constructors _couldn't_ have parameters attached to them -- that somehow this made a constructor no longer a constructor. 
      </p>
      <p>
        Instead, if we showed early examples of constructors with parameters, the whole idea of a constructor makes much more sense. 
      </p>
    </div>
  </div>
  <div class="grid-code-only">
    <div class="code-block">
      <pre>
var date_of_birth = new DateTime(1980,1,3);
Person mary = new Person("Mary", date_of_birth);</pre>
    </div>
  </div>
  <div class="grid-content">
    <div class="content">
      <p>
        Ah, I see... we're creating a person named Mary born on January 3rd, 1980.
      </p>
      <p>
        Of course, we know that constructors can have parameters. In fact, most well-written objects will have parameterized constructors that, in particular, accept data that can only be given during the instance's construction. This leads to all sorts of other concepts that bring out the empassioned object-oriented audience like immutability and hiding implementation details.
      </p>
      <p>
        Also, idea of a parameter name neeed not be the name of the passed in thing!!!!
      </p>
      <p>
        (string myText) doesnt have to pass something called myText. Show SCOPE. Silly things we take for granted but a newbie wouldnt.
      [Finish]
      </p>
    </div>
  </div>
</div>

<div class="chapter" id="ch-about-this-book">
<div class="grid-content">
  <div class="content">
    <h2>About this book</h2>
    <p>Hey there.
    </p>
    <p>I'd like to thank a few (well-known) folks in the programming industry that provided some valuable insights into how they write code. Their thoughts gave me direction in my own thinking while writing this book.
    </p>
    <ul>
      <li>Eric Evans</li>
      <li>Martin Fowler</li>
      <li>David Heinemeier Hansson</li>
      <li>Sandi Metz</li>
      <li>Brandon Rhodes</li>
    </ul>
<p>Also, a special thanks to <a href="https://www.tartworkshop.com/">Tart Workshop</a>, the creator of the excellent handwritten font <a href="https://fonts.google.com/specimen/Fredericka+the+Great" style="font-family:'Fredericka the Great' !important">Frederika the Great</a> that I've used for the title and headings. I had no idea what "character" this book would have when I began designing the layout. This font became a lot of that character.</p>
  </div>
</div>
</div>



<div id="grid-prev-next">
  <div class="prev"></div>
  <div class="next"></div>
</div>

</body>

<!--

Other notes:

ONT: Email methods -- sendExternalUserEmail DRY up vs. split out to a postmark_ses_thing() because relationship to loggability is different than 'from' address thing. - COMPLETE

ONT: SQSCourier extraction (Name: Courier -- rather than helper/wrapper etc. because of the methods it has -- sending to queue, pulling from queue)


-->


<script>
  
  $(function() {

    var assetOriginal = "";
    var hasAssetRolloverPad = "0";
    var curChapterId = "";

    $("body").delay(1000).fadeIn(1000);

    $("div.chapter").each(function(i) {
      $(this).children("div.grid-content").first().children("div.content").first().prepend("<h4>Chapter " + (i + 1) + "</h4>");
    });

    showInitialChapter();

    $(window).scroll(function (event) {

        if ($(curChapterId).offset().top - 1 <= $(window).scrollTop())
        {
          $("div.menu").fadeIn(200);
        }
        else
        {
          $("div.menu").hide();
        }

        // Do something
    });

    $("a.code-ref").hover(function(e) {
        var codeRef = $(this).data("code-ref");
        $("pre span." + codeRef).addClass("emphasis");
    });

    $("a.code-ref").click(function(e) {
        e.preventDefault();
        e.stopImmediatePropagation();
    });

    $("a.code-ref").mouseleave(function(e) {
        var codeRef = $(this).data("code-ref");
        $("pre span." + codeRef).removeClass("emphasis");
    });

    $("#btn-cover-click").click(function(e) {
        scrollToChapter(e);
    });

    $("body").on("click", "a:not('#btn-cover-click')", function(e) {
      if ($(this).attr("href").startsWith("#"))
      {
        showChapter($(this).attr("href"));
      }
    });

    $("div.menu > a").click(function(e) {
      e.preventDefault();
      $("div.toc").show();
    });

    $("div.toc a").click(function(e) {
      $("div.toc").hide();
    });



    function showChapter(chapterId)
    {
      curChapterId = chapterId;

      if (chapterId == "#ch-introduction")
      {
        $("#btn-cover-click").html("Start reading...");
      }
      else
      {
        $("#btn-cover-click").html("Keep reading...");
      }


      $("div.chapter").hide();

      $("div.toc > ul > li > a").removeClass("selected");
      $("div.toc > ul > li").find("a[href='" + chapterId + "']").addClass("selected");

      $(chapterId).fadeIn(200);

      var prevChapter = $(chapterId).prev(".chapter");
      var nextChapter = $(chapterId).next(".chapter");
      var prevLinkHolder = $("#grid-prev-next").find("div").first();
      var nextLinkHolder = $("#grid-prev-next").find("div").last();

      if (prevChapter.length !== 0)
      {
        prevLinkHolder.html("<a href=\"#" + prevChapter.attr("id") + "\">&larr; " + prevChapter.find("h2").first().html() + "</a></div>");
      }
      else
      {
        prevLinkHolder.html("");
      }

      if (nextChapter.length !== 0)
      {
        nextLinkHolder.html("<a href=\"#" + nextChapter.attr("id") + "\">" + nextChapter.find("h2").first().html() + " &rarr;</a></div>");
      }
      else
      {
        nextLinkHolder.html("");
      }
    }

    function showInitialChapter()
    {
      var url = window.location.href;

      if (url.indexOf("#") <= 0 || url.indexOf("#") == url.length - 1)
      {
        showChapter("#" + $("div.chapter").first().attr("id"));
        return;
      }

      curChapterId = url.substring(url.indexOf("#"));
      showChapter(curChapterId);
    }

    function scrollToChapter(e)
    {
      e.preventDefault();

      $("body,html").animate(
        {
          scrollTop: $(curChapterId).offset().top
        },
        500 //speed
      );
    }

  });

</script>

</html>
